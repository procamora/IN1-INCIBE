#!/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import configparser
import json
from timeit import default_timer as timer

from functions import checkDir
from newConnection import NewConnection


def CreateArgParser():
    """
    Metodo para establecer los argumentos que necesita la clase

    :return:
    """
    config = configparser.ConfigParser()
    config.sections()
    config.read('settings.conf')

    example = 'python3 %(prog)s -d ../output/ -v'
    myParser = argparse.ArgumentParser(description='%(prog)s is a script to convert the JSON generated by the Parser \
                                                    into a JSON compatible with Cowrie.',
                                       usage='{}'.format(example))

    requiredNamed = myParser.add_argument_group('required named arguments')
    requiredNamed.add_argument('-d', '--dir', required=True,
                               help='Directory where the file cowrie.completed.json are located.')
    myParser.add_argument('-v', '--verbose', action='store_true', help='Verbose flag (boolean).', default=False)
    # myParser.print_help()
    return myParser.parse_args()


class Compatible(object):
    def __init__(self, verbose, directory, myConfig):
        """
        Constructor de clase

        :param verbose:
        :param directory: Directorio donde se guardan los ficheros de salida
        """
        config = configparser.ConfigParser()
        config.sections()
        config.read('settings.conf')

        checkDir(directory)

        self._verbose = verbose

        self._fileCompleted = '{}/{}'.format(directory, config[myConfig]['FILE_LOG_COMPLETED'])
        self._outputJson = '{}/{}'.format(directory, config[myConfig]['FILE_LOG_COWRIE'])

    def run(self):
        """
        Metodo para analizar todas las lineas del fichero de sesiones iniciadas pero no cerradas y guardar los
        resultados

        :return:
        """
        startTotal = timer()
        output = str()

        with open(self._fileCompleted, 'r') as f:
            totalLines = f.readlines()
            for num, lineSession in enumerate(totalLines):
                if self._verbose:
                    print('{}/{}'.format(num, len(totalLines)))
                if len(lineSession) > 2:  # Evitamos lineas en blanco (\n)
                    n = NewConnection.fromJson(json.loads(lineSession), json.loads('{}'), False)
                    #print(n.getJSONCowrie())
                    output = '{}{}'.format(output, n.getJSONCowrie())

        with open(self._outputJson, 'w') as f:
        	f.write(output)

        endTotal = timer()
        print('Tiempo total: {} seg'.format(endTotal - startTotal))  # Time in seconds, e.g. 5.38091952400282


if __name__ == '__main__':
    startTotal = timer()

    arg = CreateArgParser()
    c = Compatible(arg.verbose, arg.dir, 'DEFAULTS')
    c.run()

    endTotal = timer()
    if arg.verbose:
        print('Tiempo total: {} seg'.format(endTotal - startTotal))  # Time in seconds, e.g. 5.38091952400282
