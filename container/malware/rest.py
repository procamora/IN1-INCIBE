#!/bin/env python3
# -*- coding: utf-8 -*-

import json
import os
import re
import threading
import time
import urllib
from http import HTTPStatus  # https://docs.python.org/3/library/http.html

import requests
import wget
from filehash import FileHash
from flask import Flask, Response
from flask import request as requestFlask

import connect_sqlite
import virustotal

requests.packages.urllib3.disable_warnings()

MIME_TYPE = 'application/json'

STATES = {
    1: "Scan finished, information embedded",  # "Ok",
    2: "The requested resource is not among the finished, queued or pending scans",  # "Not Exists",
    3: "Scan request successfully queued, come back later for the report",  # "Analyzing"
    4: "Invalid resource, check what you are submitting",
    5: "In progress hash",  # Estado local, pendiente de enviar a virustotal
    6: "In progress url"  # Estado local, pendiente de enviar a virustotal
}

app = Flask(__name__)


def daemon_hashes():
    while True:
        hashes = connect_sqlite.get_inprogress_hash()
        for i in hashes:
            app.logger.info("Demonio analiza hash: {}".format(i))
            response = analize_hash(i['hash'], daemon=True)
            resp = json.loads(response)
            if 'response_code' in resp.keys() and resp['response_code'] == 204:
                break

        urls = connect_sqlite.get_inprogress_url()
        for i in urls:
            app.logger.info("Demonio analiza url: {}".format(i))
            response = analize_url(i['url'], i['file'], daemon=True)
            resp = json.loads(response)
            if 'response_code' in resp.keys() and resp['response_code'] == 204:
                break

        time.sleep(20)


def get_state_json(response):
    response = json.loads(response)
    app.logger.info("response: {}".format(response))
    app.logger.info("response_code: {}".format(response['results']['response_code']))

    if response['results']['verbose_msg'] == STATES[3]:
        return 3
    elif response['results']['verbose_msg'] == STATES[2]:
        return 2
    elif response['results']['verbose_msg'] == STATES[1]:
        return 1
    else:
        return 4


def analize_hash(param_hash, file="", url="", daemon=False):
    response = virustotal.analize_hash(param_hash)
    resp = json.loads(response)
    app.logger.info(resp)
    if 'response_code' not in resp.keys():
        connect_sqlite.insert_if_not_exits_hash(param_hash=param_hash, state=5)  # estado 5 en progreso local
        return '{"error": "Timeout connect virustotal.com"}'
    elif resp['response_code'] == 204:
        app.logger.info("Excedidas peticiones por minuto, reintendanto: {}".format(param_hash))
        connect_sqlite.insert_if_not_exits_hash(param_hash=param_hash, state=5)  # estado 5 en progreso local
        app.logger.info(connect_sqlite.get_inprogress_hash())
    else:
        app.logger.info("update_hash {} en la BD".format(param_hash))
        state = get_state_json(response)
        if daemon:
            connect_sqlite.update_hash(param_hash, response, state)
        else:
            connect_sqlite.insert_hash(param_hash, state, response, file, url)
    return response


def get_response_json(myjson, response):
    """
    Metodo usado por virustotal_hash para crear la respuesta en caso de que exista el hash en vt
    :param myjson:
    :param response:
    :return:
    """
    app.logger.info(myjson)
    if myjson['response_code'] == 204:
        return Response(response=response, status=HTTPStatus.PARTIAL_CONTENT, mimetype=MIME_TYPE)
    elif myjson['results']['response_code'] == 1:
        return Response(response=response, status=HTTPStatus.OK, mimetype=MIME_TYPE)
    else:
        return Response(response=response, status=HTTPStatus.PARTIAL_CONTENT, mimetype=MIME_TYPE)


@app.route('/', methods=['GET', 'POST'])
def hello():
    return Response(response='{"status": "ok"}', status=HTTPStatus.OK, mimetype=MIME_TYPE)


@app.route('/analize', methods=['GET'])
def virustotal_hash():
    param_hash = requestFlask.args.get('hash')

    if not connect_sqlite.is_exists_hash(param_hash):
        response = analize_hash(param_hash)
        json_response = json.loads(response)
        if 'response_code' in json_response.keys():
            return get_response_json(json_response, response)
        else:
            return Response(response=response, status=HTTPStatus.GATEWAY_TIMEOUT, mimetype=MIME_TYPE)
    else:
        app.logger.info("ya existe {}".format(param_hash))
        response = connect_sqlite.select_hash(param_hash)
        if response is not None:
            return Response(response=response['json'], status=HTTPStatus.OK, mimetype=MIME_TYPE)
        else:  # fixme el hash esta en la lista descargandose pero aun no esta en la bd
            # fixme borrar a ver que pasa
            return Response(response=response, status=HTTPStatus.INTERNAL_SERVER_ERROR, mimetype=MIME_TYPE)


@app.route('/analize', methods=['POST'])
def virustotal_url() -> json:
    values = requestFlask.get_json()
    file_url = str(values['url'])
    file_name = file_url.split('/')[-1]

    if not connect_sqlite.is_exists_url(file_url):
        app.logger.error("no existe {}".format(file_url))
        response = analize_url(file_url, file_name)
        # return response
        json_response = json.loads(response)
        if 'response_code' in json_response.keys():
            return get_response_json(json_response, response)
        else:
            return Response(response=response, status=HTTPStatus.GATEWAY_TIMEOUT, mimetype=MIME_TYPE)
    else:
        app.logger.error("ya existe {}".format(file_url))
        response = connect_sqlite.select_url(file_url)
        if response is not None:  # tenemos respuesta con estado 1
            return Response(response=response['json'], status=HTTPStatus.OK, mimetype=MIME_TYPE)
        else:  # fixme borrar a ver que pasa
            return Response(response=response['json'], status=HTTPStatus.INTERNAL_SERVER_ERROR, mimetype=MIME_TYPE)


def analize_url(file_url, file_name, daemon=False):
    response = virustotal.analize_url(file_url)
    app.logger.info(response)
    resp = json.loads(response)

    if 'response_code' not in resp.keys():
        connect_sqlite.insert_if_not_exits_url("", state=6, file=file_name, url=file_url)
        return '{"error": "Timeout connect virustotal.com"}'
    elif resp['response_code'] == 204:
        app.logger.info("Excedidas peticiones por minuto, reintendanto: {}".format(hash))
        connect_sqlite.insert_if_not_exits_url("", state=6, file=file_name, url=file_url)
        app.logger.info(connect_sqlite.get_inprogress_hash())
    else:
        app.logger.info("update_url {} en la BD".format(file_url))
        state = get_state_json(response)
        if daemon:
            connect_sqlite.update_hash(file_url, response, state)
        else:
            connect_sqlite.insert_hash("", state, response, file_name, file_url)
    return response


@app.route('/download', methods=['POST'])
def download() -> json:
    values = requestFlask.get_json()
    file_url = str(values['url'])
    file_name = file_url.split('/')[-1]

    if not connect_sqlite.is_new_url(file_url):
        response = connect_sqlite.select_url(file_url)
        if response is not None:
            return Response(response=response['json'], status=HTTPStatus.OK, mimetype=MIME_TYPE)
        else:
            return Response(response=response['json'], status=HTTPStatus.INTERNAL_SERVER_ERROR, mimetype=MIME_TYPE)

    try:
        if is_downloadable(file_url):
            x = threading.Thread(target=thread_download_file, args=(file_url, file_name))
            x.start()
            return Response(response=file_name, status=HTTPStatus.PARTIAL_CONTENT, mimetype=MIME_TYPE)
        else:
            return Response(response='{"error": "File not downloadable"}', status=HTTPStatus.FORBIDDEN,
                            mimetype=MIME_TYPE)
    except requests.exceptions.ConnectionError:
        return Response(response='{"error": "Timeout connect virustotal.com"}', status=HTTPStatus.GATEWAY_TIMEOUT,
                        mimetype=MIME_TYPE)


def is_downloadable(url) -> bool:
    """
    Does the url contain a downloadable resource
    """
    try:
        h = requests.head(url, allow_redirects=True, verify=False, timeout=5)
        header = h.headers
        content_type = header.get('content-type')
        # if 'text' in content_type.lower():
        #    return False
        if content_type is not None and 'html' in content_type.lower():
            return False
        return True
    except Exception as e:
        app.logger.info('not is_downloadable: {}'.format(url))
        return False


def thread_download_file(file_url, file_name):
    if not re.search('http://', file_url):
        file_url = 'http://{}'.format(file_url)
    app.logger.info("Thread %s: starting", file_name)
    directory = 'tmp'
    path = '{}/{}'.format(directory, file_name)
    try:
        wget.download(file_url, )
        hash_sha256 = FileHash('sha256')
        hash_file = hash_sha256.hash_file(path)
        if connect_sqlite.is_exists_hash_state(hash_file):
            app.logger.info("Insertamos %s en la BD", file_name)
            analize_hash(hash_file, file_name, file_url)  # Aqui no es un hilo

    except urllib.error as e:
        app.logger.info(e)
        # os.remove(file_name) # FIXME DESCOMENTAR
    app.logger.info("Thread %s: finishing", file_name)


if __name__ == "__main__":
    if not os.path.isfile(connect_sqlite.DB):
        app.logger.info("Creamos BD: {}".format(connect_sqlite.DB))
        with open('malware.db.sql', 'r') as f:
            connect_sqlite.ejecuta_script_sqlite(connect_sqlite.DB, f.read())

    d = threading.Thread(target=daemon_hashes, name='Daemon', daemon=True)
    d.start()
    app.run(debug=True, port=8080, host='0.0.0.0')
