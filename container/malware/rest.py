#!/bin/env python3
# -*- coding: utf-8 -*-

import datetime
import json
import logging
import os
import re
import threading
import time
import urllib
from http import HTTPStatus  # https://docs.python.org/3/library/http.html
from typing import NoReturn

import colorlog
import requests
import wget
from filehash import FileHash
from flask import Flask, Response
from flask import request as requestFlask

import colorize
import connect_sqlite
import virustotal

requests.packages.urllib3.disable_warnings()

MIME_TYPE = 'application/json'

STATES = {
    1: "Scan finished, scan information embedded in this object",  # "Ok",
    2: "The requested resource is not among the finished, queued or pending scans",  # "Not Exists",
    3: "Scan request successfully queued, come back later for the report",  # "Analyzing"
    4: "Invalid resource, check what you are submitting",
    5: "In progress hash",  # Estado local, pendiente de enviar a virustotal, lo analiza el demonio
    6: "In progress url",  # Estado local, pendiente de enviar a virustotal, lo analiza el demonio
    7: "In progress download",  # Estado local, en proceso de descarga local
    8: "Offline"
}


def update_logger(verbose: bool, name: str = 'flask.app') -> NoReturn:
    # Desabilita log de modulos
    # for _ in ("boto", "elasticsearch", "urllib3"):
    #    logging.getLogger(_).setLevel(logging.CRITICAL)

    log_format = '%(levelname)s - %(module)s -%(funcName)s- %(message)s'

    bold_seq = '\033[1m'
    colorlog_format = (
        f'{bold_seq} '
        '%(log_color)s '
        f'{log_format}'
    )

    colorlog.basicConfig(format=colorlog_format)
    # logging.basicConfig(format=colorlog_format)
    log = logging.getLogger(name)

    if verbose:
        log.setLevel(logging.DEBUG)
    else:
        log.setLevel(logging.INFO)

    return log


app = Flask(__name__)
mutex = threading.Lock()
colorize.colorize_werkzeug()

# Actualizamos logger para que tenga el formato deseado con colores
logger = update_logger(True)


def daemon_hashes() -> NoReturn:
    while True:
        # analiza los hash en proceso
        hashes = connect_sqlite.get_inprogress_hash()
        logger.debug(f"Demonio tiene en espera: {len(hashes)} hashes")
        for i in hashes:
            logger.info(f"Demonio analiza hash: {i}")
            response = analize_hash(i['hash'], daemon=True)
            resp = json.loads(response)
            if 'response_code' in resp.keys() and resp['response_code'] == 204:
                break

        # analiza las urls en proceso
        urls = connect_sqlite.get_inprogress_url()
        logger.debug(f"Demonio tiene en espera: {len(urls)} urls")
        for i in urls:
            logger.info("Demonio analiza url: {}".format(i))
            response = analize_url(i['url'], i['file'], daemon=True)
            resp = json.loads(response)
            if 'response_code' in resp.keys() and resp['response_code'] == 204:
                break

        # analiza las url que esta analizando vt por peticion nuestra
        urls = connect_sqlite.get_inprogress_url_for_vt()
        logger.debug(f"Demonio tiene en espera: {len(urls)} urls vt")
        for i in urls:
            logger.info("Demonio analiza url de vt: {}".format(i))
            response = update_json_url(i['url'], i['file'])
            resp = json.loads(response)
            if 'response_code' in resp.keys() and resp['response_code'] == 204:
                break

        time.sleep(20)


def get_state_json(response: str) -> int:
    response = json.loads(response)
    # logger.debug("response: {}".format(response))
    # logger.info("response_code: {}".format(response['results']['response_code']))

    if response['results']['verbose_msg'] == STATES[3]:
        return 3
    elif response['results']['verbose_msg'] == STATES[2]:
        return 2
    elif response['results']['verbose_msg'] == STATES[1]:
        return 1
    else:
        return 4


def analize_hash(param_hash, file="", url="", daemon=False) -> str:
    response = virustotal.analize_hash(param_hash)
    resp = json.loads(response)
    logger.info(resp)
    if 'response_code' not in resp.keys():
        connect_sqlite.insert_if_not_exits_hash(mutex, param_hash, 5, response, file, url)  # estado 5 en progreso local
        return '{"error": "Timeout connect virustotal.com"}'
    elif resp['response_code'] == 204:
        logger.info("Excedidas peticiones por minuto, reintendanto: %s", param_hash)
        connect_sqlite.insert_if_not_exits_hash(mutex, param_hash, 5, response, file, url)  # estado 5 en progreso local
        logger.info(connect_sqlite.get_inprogress_hash())
    else:
        logger.info("update_hash {} en la BD".format(param_hash))
        state = get_state_json(response)
        if daemon:
            connect_sqlite.update_hash(mutex, param_hash, response, state)
        else:
            connect_sqlite.insert_if_not_exits_hash(mutex, param_hash, state, response, file,
                                                    url)  # fixme antes insert_hash
    return response


def get_response_json(myjson, response) -> Response:
    """
    Metodo usado por virustotal_hash para crear la respuesta en caso de que exista el hash en vt
    :param myjson:
    :param response:
    :return:
    """
    # logger.info(myjson)
    if myjson['response_code'] == 204:
        return Response(response=response, status=HTTPStatus.PARTIAL_CONTENT, mimetype=MIME_TYPE)
    elif myjson['results']['response_code'] == 1:
        return Response(response=response, status=HTTPStatus.OK, mimetype=MIME_TYPE)
    else:
        return Response(response=response, status=HTTPStatus.PARTIAL_CONTENT, mimetype=MIME_TYPE)


@app.route('/', methods=['GET', 'POST'])
def hello() -> Response:
    return Response(response='{"status": "ok"}', status=HTTPStatus.OK, mimetype=MIME_TYPE)


@app.route('/analizeHash', methods=['GET'])
def rest_analize_hash() -> Response:
    param_hash = requestFlask.args.get('hash')
    logger.info(f'analizeHash: {param_hash}')
    if not connect_sqlite.is_exists_hash(param_hash):
        response = analize_hash(param_hash)
        json_response = json.loads(response)
        if 'response_code' in json_response.keys():
            return get_response_json(json_response, response)
        else:
            return Response(response=response, status=HTTPStatus.GATEWAY_TIMEOUT, mimetype=MIME_TYPE)
    else:
        response = connect_sqlite.select_hash(param_hash)
        if response is not None:
            return Response(response=response['json'], status=HTTPStatus.OK, mimetype=MIME_TYPE)
        else:  # fixme el hash esta en la lista descargandose pero aun no esta en la bd
            # fixme borrar a ver que pasa
            return Response(response=response, status=HTTPStatus.INTERNAL_SERVER_ERROR, mimetype=MIME_TYPE)


@app.route('/analizeUrl', methods=['POST'])
def rest_analize_url() -> Response:
    """
    Metodo para preguntar por la peligrosidad de una url, es llamado despues de haberse descargado el fichero
    y generar el hash, por lo que tiene que actualizar el json ya existente
    :return:
    """
    values = requestFlask.get_json()
    if values is None:
        logger.error("analizeUrl %s", values)
        return Response(response='{"error": "Param url not found"}', status=HTTPStatus.BAD_REQUEST, mimetype=MIME_TYPE)
    logger.info(f'analizeUrl: {values}')
    file_url = str(values['url'])
    file_name = file_url.split('/')[-1]

    if not connect_sqlite.is_exists_url_state(file_url):
        response = analize_url(file_url, file_name)
        # return response
        json_response = json.loads(response)
        if 'response_code' in json_response.keys():
            return get_response_json(json_response, response)
        else:
            return Response(response=response, status=HTTPStatus.GATEWAY_TIMEOUT, mimetype=MIME_TYPE)
    else:
        response = connect_sqlite.select_url(file_url)
        if response is not None:  # tenemos respuesta con estado 1
            return Response(response=response['json'], status=HTTPStatus.OK, mimetype=MIME_TYPE)
        else:  # fixme borrar a ver que pasa
            return Response(response=response['json'], status=HTTPStatus.INTERNAL_SERVER_ERROR, mimetype=MIME_TYPE)


def analize_url(file_url: str, file_name: str, daemon: bool = False) -> str:
    response = virustotal.analize_url(file_url)
    logger.debug(response)
    resp = json.loads(response)

    if 'response_code' not in resp.keys():
        connect_sqlite.insert_if_not_exits_url(mutex, file=file_name, url=file_url, state=6)
        return '{"error": "Timeout connect virustotal.com"}'
    elif resp['response_code'] == 204:
        logger.info("Excedidas peticiones por minuto, reintendanto: {}".format(file_url))
        connect_sqlite.insert_if_not_exits_url(mutex, file=file_name, url=file_url, state=6)
        logger.info(connect_sqlite.get_inprogress_url())
    else:
        logger.info("update_url {} en la BD".format(file_url))
        state = get_state_json(response)
        if daemon:
            connect_sqlite.update_url(mutex, file_url, response, state)
        else:
            # si existe la url la actualizamos, sino existe se inserta
            if connect_sqlite.is_exists_url(file_url):
                connect_sqlite.update_url(mutex, file_url, response, state)
            else:
                connect_sqlite.insert_hash(mutex, "", state, response, file_name, file_url)
    return response


def update_json_url(file_url: str, file_name: str) -> str:
    """
    Metodo para tratar la respuesta que da vt de una url que ha analizado anteriormente
    :param file_url:
    :param file_name:
    :return:
    """
    response = virustotal.url_report(file_url)
    resp = json.loads(response)

    if 'response_code' not in resp.keys():
        connect_sqlite.insert_if_not_exits_url(mutex, file=file_name, url=file_url, state=6)
        return '{"error": "Timeout connect virustotal.com"}'
    elif resp['response_code'] == 204:
        logger.info("Excedidas peticiones por minuto, reintendanto: {}".format(file_url))
        connect_sqlite.insert_if_not_exits_url(mutex, file=file_name, url=file_url, state=6)
        logger.info(connect_sqlite.get_inprogress_url())
    else:
        logger.debug("update_json_url {} en la BD".format(file_url))
        state = get_state_json(response)
        connect_sqlite.update_url(mutex, file_url, response, state)
    return response


@app.route('/downloadUrl', methods=['POST'])
def rest_download_url() -> Response:
    values = requestFlask.get_json()
    if values is None:
        logger.error("downloadUrl %s", values)
        return Response(response='{"error": "Param url not found"}', status=HTTPStatus.BAD_REQUEST, mimetype=MIME_TYPE)

    logger.info(f'downloadUrl: {values}')
    file_url = str(values['url'])
    file_name = file_url.split('/')[-1]

    # VER PORQUE NO SE AÑADE EL HASH DE LOS ICHEROS SI YA ESTA EN LA BD

    # Si existe la url enviamos la respuesta que hay en la bd
    # FIXME is_exists_url_state
    if connect_sqlite.is_exists_url(file_url):
        response = connect_sqlite.select_url(file_url)
        if response is not None:
            return Response(response=response['json'], status=HTTPStatus.OK, mimetype=MIME_TYPE)
        else:
            return Response(response='{"error": "INTERNAL_SERVER_ERROR"}', status=HTTPStatus.INTERNAL_SERVER_ERROR,
                            mimetype=MIME_TYPE)

    try:
        if is_downloadable(file_url):
            x = threading.Thread(target=thread_download_file, args=(file_url, file_name))
            x.start()
            return Response(response='{"msg":"in progress"}', status=HTTPStatus.PARTIAL_CONTENT, mimetype=MIME_TYPE)
        else:
            connect_sqlite.insert_if_not_exits_url(mutex, file_name, file_url, 8, "{}", "")  # fichero offline
            return Response(response='{"error": "File not downloadable"}', status=HTTPStatus.FORBIDDEN,
                            mimetype=MIME_TYPE)
    except requests.exceptions.ConnectionError:
        return Response(response='{"error": "Timeout connect virustotal.com"}', status=HTTPStatus.GATEWAY_TIMEOUT,
                        mimetype=MIME_TYPE)


@app.route('/getHash', methods=['POST'])
def rest_get_hash_url() -> Response:
    """
    Metodo para preguntar por el hash de una url, si existe es porque antes se ha descargado el fichero y ha generado
    el hash
    :return:
    """
    values = requestFlask.get_json()
    if values is None:
        logger.error("rest_get_hash_url %s", values)
        return Response(response='{"error": "Param url not found"}', status=HTTPStatus.BAD_REQUEST, mimetype=MIME_TYPE)

    logger.info(f'getHash: {values}')
    file_url = str(values['url'])

    if not connect_sqlite.is_exists_url(file_url):
        return Response(response='{"error": "hash not exists"}', status=HTTPStatus.NOT_FOUND, mimetype=MIME_TYPE)
    else:
        response = connect_sqlite.select_url(file_url)
        response_json = '{"hash": "%s"}' % response['hash']
        return Response(response=response_json, status=HTTPStatus.OK, mimetype=MIME_TYPE)


def is_downloadable(url: str) -> bool:
    """
    Does the url contain a downloadable resource
    """
    try:
        h = requests.head(url, allow_redirects=True, verify=False, timeout=5)
        header = h.headers
        content_type = header.get('content-type')
        # if 'text' in content_type.lower():
        #    return False
        if content_type is not None and 'html' in content_type.lower():
            return False
        return True
    except Exception as e:
        logger.info('not is_downloadable: {}'.format(url))
        return False


def thread_download_file(file_url: str, file_name: str) -> NoReturn:
    if not re.search(r'https?://', file_url):
        # FIXME CUIDADO, PONGO HTTP Y NO HTTPS NO SE SI DARA ALGUN PROBLEMA
        file_url = 'http://{}'.format(file_url)

    logger.debug("Thread %s: starting", file_name)
    directory = './download'
    path = f'{directory}/{datetime.datetime.now().timestamp()}{file_name}'

    logger.debug("download url %s in %s", file_url, path)
    # wget da error si existe el fichero que queremos descargar
    if os.path.exists(path):
        os.remove(path)
    try:
        wget.download(file_url, path)
        hash_sha256 = FileHash('sha256')
        hash_file = hash_sha256.hash_file(path)
        logger.info("file %s, hash %s", file_name, hash_file)
        if not connect_sqlite.is_exists_hash(hash_file):
            logger.debug("Insertamos %s en la BD", file_name)
            analize_hash(hash_file, file_name, file_url)
        else:
            logger.info("exists %s in database", file_name)
    except urllib.error.HTTPError:
        # fixme ver como retorno la info
        logger.error("the page blocks the download: %s", file_url)

    # os.remove(path) # FIXME DESCOMENTAR
    logger.debug("Thread %s: finishing", file_name)


def get_reputation_ip(ip) -> int:
    req_headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0'}
    response = requests.get('https://threatwar.com/ip/{}'.format(ip), headers=req_headers, verify=False)

    if response.status_code == 200:
        regex = r'<td>Total Attacks<\/td>( )*(\n)?( )*<td>(\d+)<\/td>'
        if re.search(regex, response.text):
            reputation = int(re.search(regex, response.text).group(4))
            logger.info('reputation ip {}: {}'.format(ip, reputation))
            return reputation  # reputacion de la ip
        return -1  # ip no se ha podido analizar
    return -2  # ip no se encuentra


@app.route('/getReputationIp', methods=['GET'])
def rest_get_reputation_ip():
    """
    Metodo para preguntar por la reputacion de una ip, si existe es porque antes se ha preguntado por ella
    :return:
    """
    param_ip = requestFlask.args.get('ip')
    logger.info(f'getReputationIp: {param_ip}')
    # si no existe pregunta por ella
    if not connect_sqlite.is_exists_ip(param_ip):
        reputation = get_reputation_ip(param_ip)
        connect_sqlite.insert_reputation_ip(mutex, param_ip, reputation)
        response_json = '{"reputation": %d}' % reputation
        if reputation >= 0:
            status_http = HTTPStatus.OK
        else:
            status_http = HTTPStatus.NOT_FOUND
        return Response(response=response_json, status=status_http, mimetype=MIME_TYPE)
    else:
        response = connect_sqlite.select_ip(param_ip)
        response_json = '{"reputation": %d}' % response['reputation']
        return Response(response=response_json, status=HTTPStatus.OK, mimetype=MIME_TYPE)


if __name__ == "__main__":
    if not os.path.isfile(connect_sqlite.DB):
        logger.info("Creamos BD: {}".format(connect_sqlite.DB))
        with open('malware.db.sql', 'r') as f:
            connect_sqlite.ejecuta_script_sqlite(connect_sqlite.DB, f.read())

    d = threading.Thread(target=daemon_hashes, name='Daemon', daemon=True)
    d.start()
    app.run(debug=True, port=8080, host='0.0.0.0')
