#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sqlite3
from threading import Lock
from typing import Dict, Any, List, Union, NoReturn

DB = "malware.db"


#UPDATE hash SET state = 3 WHERE state <> 1

def conection_sqlite(db: str, query: str, mutex: Lock = None, is_dict: bool = False) \
        -> Union[List[Dict[str, Any]], None]:
    if mutex is not None:
        mutex.acquire()  # bloqueamos acceso a db
    try:
        if os.path.exists(db):
            conn = sqlite3.connect(db)
            if is_dict:
                conn.row_factory = dict_factory
            cursor = conn.cursor()
            cursor.execute(query)

            if query.upper().startswith('SELECT'):
                data = cursor.fetchall()  # Traer los resultados de un select
            else:
                conn.commit()  # Hacer efectiva la escritura de datos
                data = None

            cursor.close()
            conn.close()
            #if mutex is not None:
            #    mutex.release()  # liberamos mutex
            return data
    except sqlite3.OperationalError:
        print(f'LOCK {query}, sorry...')
    finally:
        if mutex is not None:
           mutex.release()  # liberamos mutex


def dict_factory(cursor, row) -> Dict:
    d = dict()
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d


def ejecuta_script_sqlite(db: str, script: str) -> NoReturn:
    conn = sqlite3.connect(db)
    cursor = conn.cursor()
    cursor.executescript(script)
    conn.commit()
    cursor.close()
    conn.close()


def dump_database(db: str) -> str:
    """
    Hace un dump de la base de datos y lo retorna
    :param db: ruta de la base de datos
    :return dump: volcado de la base de datos 
    """
    if os.path.exists(db):
        con = sqlite3.connect(db)
        # noinspection PyTypeChecker
        return '\n'.join(con.iterdump())


# un hash existe si esta en la bd independientemenete del estado
def is_exists_hash(param_hash: str) -> bool:
    query = f"SELECT * FROM hash WHERE hash LIKE '{param_hash}'"
    response = conection_sqlite(DB, query, is_dict=True)
    if len(response) == 0:
        return False
    return True


# un hash existe si esta en la bd con state 1 (Ok)
def is_exists_hash_state(param_hash: str) -> bool:
    """
    Metodo que comprueba que si un hash en proceso de analisis o ya se ha analizado y se tiene su valor
    Si el hash esta en proceso o con un valor 1 retorna False
    Si no exite en la BD retorna True
    :param param_hash:
    :return:
    """
    query = f"SELECT * FROM hash WHERE hash LIKE '{param_hash}' AND STATE LIKE 1"
    response = conection_sqlite(DB, query, is_dict=True)
    if len(response) == 0:  # Si NO existe es un nuevo hash
        return False
    return True


# un hash existe si esta en la bd con state 1 (Ok)
def is_exists_url(url: str) -> bool:
    query = f"SELECT * FROM hash WHERE url LIKE '{url}'"
    response = conection_sqlite(DB, query, is_dict=True)
    if len(response) == 0:
        return False
    return True


# un hash existe si esta en la bd con state 1 (Ok)
def is_exists_url_state(url: str) -> bool:
    """
    Si la url esta ya analizada o esta offline retorno True, sino False
    :param url:
    :return:
    """
    query = f"SELECT * FROM hash WHERE url LIKE '{url}' AND state LIKE 1"
    response = conection_sqlite(DB, query, is_dict=True)
    if len(response) == 0:
        return False
    return True


def select_hash(param_hash: str) -> Union[Dict[str, Any], None]:
    query = f"SELECT * FROM hash WHERE hash LIKE '{param_hash}'"
    response = conection_sqlite(DB, query, is_dict=True)
    if len(response) > 0:
        return response[0]
    return None


def select_url(url: str) -> Union[Dict[str, Any], None]:
    query = f"SELECT * FROM hash WHERE url LIKE '{url}'"
    response = conection_sqlite(DB, query, is_dict=True)
    if len(response) > 0:
        return response[0]
    return None


def get_inprogress_hash() -> List[Dict[str, Any]]:
    query = "SELECT * FROM hash WHERE state LIKE 5"
    response = conection_sqlite(DB, query, is_dict=True)
    return response


def get_inprogress_url() -> List[Dict[str, Any]]:
    query = "SELECT * FROM hash WHERE state LIKE 6"
    response = conection_sqlite(DB, query, is_dict=True)
    return response


def get_inprogress_url_for_vt() -> List[Dict[str, Any]]:
    query = "SELECT * FROM hash WHERE state LIKE 3"
    response = conection_sqlite(DB, query, is_dict=True)
    return response


def insert_hash(mutex: Lock, param_hash: str, state: int, njson: str = "", file: str = "", url: str = "") -> NoReturn:
    query = f"INSERT INTO hash(file, hash, json, url, state) VALUES ('{file}', '{param_hash}', '{njson}', '{url}', " \
        f"{state})"
    conection_sqlite(DB, query, mutex)


def insert_if_not_exits_hash(mutex: Lock, param_hash: str, state: int, njson: str = "", file: str = "",
                             url: str = "") -> NoReturn:
    if not is_exists_hash(param_hash):
        query = f"INSERT INTO hash(file, hash, json, url, state) VALUES ('{file}', '{param_hash}', '{njson}', '{url}'" \
            f", {state})"
        conection_sqlite(DB, query, mutex)


def insert_if_not_exits_url(mutex: Lock, file: str, url: str, state: int, njson: str = "",
                            param_hash: str = "") -> NoReturn:
    if not is_exists_url(url):
        query = f"INSERT INTO hash(file, hash, json, url, state) VALUES ('{file}', '{param_hash}', '{njson}', " \
            f"'{url}', {state})"
        conection_sqlite(DB, query, mutex)


def update_hash(mutex: Lock, param_hash: str, njson: str, state: int) -> NoReturn:
    query = f"UPDATE hash SET json = '{njson}', state = {state} WHERE hash = '{param_hash}'"
    conection_sqlite(DB, query, mutex)


def update_url(mutex: Lock, url: str, njson: str, state: int) -> NoReturn:
    query = f"UPDATE hash SET json = '{njson}', state = {state} WHERE url = '{url}'"
    conection_sqlite(DB, query, mutex)


# un ip existe si esta en la bd con state 1 (Ok)
def is_exists_ip(ip: str) -> bool:
    query = f"SELECT * FROM ip WHERE ip LIKE '{ip}'"
    response = conection_sqlite(DB, query, is_dict=True)
    if len(response) == 0:
        return False
    return True


def select_ip(ip: str) -> Union[Dict[str, Any], None]:
    query = f"SELECT * FROM ip WHERE ip LIKE '{ip}'"
    response = conection_sqlite(DB, query, is_dict=True)
    if len(response) > 0:
        return response[0]
    return None


def insert_reputation_ip(mutex: Lock, ip: str, reputation: int) -> NoReturn:
    query = f"INSERT INTO ip(ip, reputation) VALUES ('{ip}', {reputation})"
    conection_sqlite(DB, query, mutex)
