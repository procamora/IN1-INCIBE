#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sqlite3
from typing import Dict, Any, List, Union, NoReturn

DB = "malware.db"


def conection_sqlite(db, query, is_dict=False) -> Union[List[Dict[str, Any]], None]:
    if os.path.exists(db):
        conn = sqlite3.connect(db)
        if is_dict:
            conn.row_factory = dict_factory
        cursor = conn.cursor()
        cursor.execute(query)

        if query.upper().startswith('SELECT'):
            data = cursor.fetchall()  # Traer los resultados de un select
        else:
            conn.commit()  # Hacer efectiva la escritura de datos
            data = None

        cursor.close()
        conn.close()

        return data


def dict_factory(cursor, row) -> Dict:
    d = dict()
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d


def ejecuta_script_sqlite(db, script) -> NoReturn:
    conn = sqlite3.connect(db)
    cursor = conn.cursor()
    cursor.executescript(script)
    conn.commit()
    cursor.close()
    conn.close()


def dump_database(db) -> str:
    """
    Hace un dump de la base de datos y lo retorna
    :param db: ruta de la base de datos
    :return dump: volcado de la base de datos 
    """
    if os.path.exists(db):
        con = sqlite3.connect(db)
        # noinspection PyTypeChecker
        return '\n'.join(con.iterdump())


# un hash existe si esta en la bd independientemenete del estado
def is_exists_hash(param_hash: str) -> bool:
    query = "SELECT * FROM hash WHERE hash LIKE '{}'".format(param_hash)
    response = conection_sqlite(DB, query, True)
    if len(response) == 0:
        return False
    return True


# un hash existe si esta en la bd con state 1 (Ok)
def is_exists_hash_state(param_hash: str) -> bool:
    """
    Metodo que comprueba que si un hash en proceso de analisis o ya se ha analizado y se tiene su valor
    Si el hash esta en proceso o con un valor 1 retorna False
    Si no exite en la BD retorna True
    :param param_hash:
    :return:
    """
    query = "SELECT * FROM hash WHERE hash LIKE '{}' AND state LIKE 1".format(param_hash)
    response = conection_sqlite(DB, query, True)
    if len(response) == 0:  # Si NO existe es un nuevo hash
        return False
    return True


# un hash existe si esta en la bd con state 1 (Ok)
def is_exists_url(url) -> bool:
    query = "SELECT * FROM hash WHERE url LIKE '{}'".format(url)
    response = conection_sqlite(DB, query, True)
    if len(response) == 0:
        return False
    return True


def select_hash(param_hash) -> Union[Dict[str, Any], None]:
    query = "SELECT * FROM hash WHERE hash LIKE '{}'".format(param_hash)
    response = conection_sqlite(DB, query, True)
    if len(response) > 0:
        return response[0]
    return None


def select_url(url) -> Union[Dict[str, Any], None]:
    query = "SELECT * FROM hash WHERE url LIKE '{}'".format(url)
    response = conection_sqlite(DB, query, True)
    if len(response) > 0:
        return response[0]
    return None


def get_inprogress_hash() -> List[Dict[str, Any]]:
    query = "SELECT * FROM hash WHERE state LIKE 5"
    response = conection_sqlite(DB, query, True)
    return response


def get_inprogress_url() -> List[Dict[str, Any]]:
    query = "SELECT * FROM hash WHERE state LIKE 6"
    response = conection_sqlite(DB, query, True)
    return response


def insert_hash(param_hash, state, njson="", file="", url="") -> NoReturn:
    query = "INSERT INTO hash(file, hash, json, url, state) VALUES ('{}', '{}', '{}', '{}', {})".format(
        file, param_hash, njson, url, state)
    conection_sqlite(DB, query)


def insert_if_not_exits_hash(param_hash, state, njson="", file="", url="") -> NoReturn:
    if not is_exists_hash(param_hash):
        query = "INSERT INTO hash(file, hash, json, url, state) VALUES ('{}', '{}', '{}', '{}', {})".format(
            file, param_hash, njson, url, state)
        conection_sqlite(DB, query)


def insert_if_not_exits_url(file, url, state, njson="", param_hash="") -> NoReturn:
    if not is_exists_url(url):
        query = "INSERT INTO hash(file, hash, json, url, state) VALUES ('{}', '{}', '{}', '{}', {})".format(
            file, param_hash, njson, url, state)
        conection_sqlite(DB, query)


def update_hash(hash, njson, state) -> NoReturn:
    # app.logger.info("md5: {}".format(md5))
    query = "UPDATE hash SET json = '{}', state = {} WHERE hash = '{}'".format(njson, state, hash)
    conection_sqlite(DB, query)


def update_url(url, njson, state) -> NoReturn:
    # app.logger.info("md5: {}".format(md5))
    query = "UPDATE hash SET json = '{}', state = {} WHERE url = '{}'".format(njson, state, url)
    conection_sqlite(DB, query)
